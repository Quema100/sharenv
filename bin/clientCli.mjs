#!/usr/bin/env node

import { program } from 'commander';
import fetch from 'node-fetch';
import path from 'path'
import fs from 'fs';

program
  .name('sharenv')
  .description('Fetch environment variables from sharenv server and create .env file')
  .version('1.0.0');

program
  .command('pull')
  .description('Download env variables and generate .env file')
  .requiredOption('-p, --project <project>', 'Project name')
  .requiredOption('-e, --env <env>', 'Environment name (dev/stage/prod)')
  .requiredOption('-u, --url <url>', 'Sharenv server base URL, e.g. http://localhost:3000')
  .option('-t, --token <token>', 'Authentication token')
  .option('-o, --output <path>', 'File path to save to (default: .env)', '.env.example')
  .action(async (opts) => {
    const { project, url, env, token, output } = opts;

    const headers = {
      'Content-Type': 'application/json',
      ...(token && { 'x-forwarded-for': token })
    };

    try {
      const res = await fetch(`${url}/api/v1/env/${project}/${env}`, {
        method: 'GET',
        headers: headers
      });
      if (!res.ok) {
        console.error(`Failed to fetch env: ${res.status} ${res.statusText}`);
        process.exit(1);
      }
      const envJson = await res.json();

      let envText = '# Generated by SecurEnv\n';
      for (const [key, value] of Object.entries(envJson)) {
        envText += `${key}=${value}\n`;
      }

      const outputPath = path.resolve(process.cwd(), output);
      const outputDir = path.dirname(outputPath);

      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      fs.writeFileSync(outputPath, envText);
      console.log(`Success! Environment variables saved to '${output}'.`);

    } catch (err) {
      console.error('Error:', err.message);
      process.exit(1);
    }
  });

program.parse(process.argv);
